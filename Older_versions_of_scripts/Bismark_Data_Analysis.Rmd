---
title: "Bismark Data Analysis"
author:
- name: Martin Treppner
  affiliation: Institute of Medical Biometry and Statistics, Faculty of Medicine and Medical Center - University of Freiburg
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  BiocStyle::html_document:
    number_sections: yes
    toc: true
    toc_depth: 2
---

## Loading packages and setting working directory  

```{r packages, message=FALSE, warning=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(readr,data.table,dplyr,tools,SingleCellExperiment,HDF5Array,mvoutlier,scran,scater,SC3,Seurat,slingshot,gam, stringr, Biocstyle, org.Mm.eg.db, mclust, RColorBrewer)

knitr::opts_chunk$set(cache=FALSE, cache.path = 'cache/', include=TRUE, 
  fig.width=8.8, fig.height=6.3, fig.path='figures/', fig.show='hold', dev='png', message=FALSE, warning=FALSE, comment=NA, echo=TRUE, tidy=TRUE, concordance=TRUE, autodep=TRUE)

if (Sys.getenv("USERNAME")== "treppner"){
    knitr::opts_knit$set(root.dir="C:/Users/treppner/Dropbox/PhD/scRNA-seq/BismarkData")
  } else if (Sys.getenv("USERNAME")==""){
    knitr::opts_knit$set(root.dir="/Users/martman/Dropbox/PhD/scRNA-seq/AdrianData/scRNAseq_data_all")
  } else {
  stop("please add your username and working directory above the last else if (see sample below)!")
}

```
# Data preparation  

## Loading data matrix  

Convert data to "SingleCellExperiment" Class.

```{r loading, echo=TRUE}
data <- readRDS("Bismark.RData")
sce <- SingleCellExperiment(list(counts=as.matrix(data)))
sce
```

## Add batches and conditions to metadata  

According to Bismark, batches 1-4 are DMSO 24h and DMSO 48h. Batches 5 and 6 are EPZ.

```{r metadata, include=TRUE, echo=TRUE}
sce$plates <- as.factor(substring(colnames(sce),9,9))

epz <- c(which(sce$plates == 5),which(sce$plates == 6))
#dmso <- sce$plates[-epc]
load("dmso_24h_names.RData")
load("dmso_48h_names.RData")

sce$condition <- "NA"
sce$condition[which(colnames(sce) %in% dmso_24h_names)] <- "DMSO24"
sce$condition[which(colnames(sce) %in% dmso_48h_names)] <- "DMSO48"
sce$condition[epz] <- "EPC"

#condition <- c(rep("DMSO", length(dmso)),rep("EPC", length(epc)))

#sce$condition <- condition
table(sce$plates)
table(sce$condition)
```

## Add mitochondrial genes and ERCC spike-ins to sce object  

There were no ERCC spike-ins used in the experiment.

```{r spikeins, include=TRUE, echo=TRUE}
isSpike(sce, "MT") <- rownames(sce)[grep("^(mt)",rownames(sce),invert=FALSE)]
isSpike(sce, "ERCC") <- rownames(sce)[grep("^(ERCC)",rownames(sce),invert=FALSE)]
sce
```

# Quality control  

## Remove genes that are not expressed  

```{r removegenes, include=TRUE, echo=TRUE}
keep_feature <- rowSums(counts(sce) > 0) > 0
sce <- sce[keep_feature,]
```

## Calculate quality metrics  

It seems like there were no ERCC spike-ins used.

```{r qualitymetrics, include=TRUE, echo=TRUE}
sce <- calculateQCMetrics(sce)
```

```{r qualplot, include=TRUE, fig.height=10, fig.width=10}
multiplot(cols=2,
    plotColData(sce, x="condition", y="total_counts"),
    plotColData(sce, x="condition", y="total_features_by_counts"),
    plotColData(sce, x="condition", y="pct_counts_MT")
)
```

Remove ERCC spike-ins since they were not used.

```{r removeercc}
sce <- sce[grep("^(ERCC|Gm|Rik)",row.names(sce),invert=TRUE),]
```


## Visualize library sizes  

```{r, include=TRUE}
hist(
    sce$total_counts,
    breaks = 100
)
abline(v = 2500, col = "red")
```

## Filter cells by library size > 2500  

```{r, include=TRUE}
filter_by_total_counts <- (sce$total_counts > 2500)
table(filter_by_total_counts)
```

```{r, include=TRUE}
sce <- sce[,filter_by_total_counts]
```

## Visualize the total number of unique genes detected in each sample  

```{r, include=TRUE}
hist(
    sce$total_features_by_counts,
    breaks = 100
)
abline(v = 1000, col = "red")
```

## Filter cells by expressed features > 1000  

```{r, include=TRUE}
filter_by_expr_features <- (sce$total_features_by_counts > 1000)
table(filter_by_expr_features)
```

```{r, include=TRUE}
sce <- sce[,filter_by_expr_features]
```

Cells with outlier values for mitochondrial genes are identified based on some number of MADs from the median value.

```{r, include=TRUE}
high.mt <- isOutlier(sce$pct_counts_MT, nmads=3, type="higher", batch=sce$condition)
data.frame(HighMito=sum(high.mt))
```

We only retain cells that pass all of the specified criteria.
Of course, this involves some assumptions about independence from biology. 
(For example, don't use the mitochondrial proportions if the number/activity of mitochondria changes between cell types.)

```{r, include=TRUE}
discard <- high.mt
data.frame(TotalLost=sum(discard), TotalLeft=sum(!discard))
```

We toss out the cells that we consider to be low-quality, and keep the rest.

```{r, include=TRUE}
sce <- sce[,!discard]
ncol(sce)
```

https://scrnaseq-course.cog.sanger.ac.uk/website/cleaning-the-expression-matrix.html#exprs-qc

```{r, include=TRUE}
plotColData(sce, x = "total_features_by_counts", y = "pct_counts_MT")
```

# Examining the genes

We inspect the distribution of log-mean counts across all genes.
The peak represents the bulk of moderately expressed genes while the rectangular component corresponds to lowly expressed genes.

```{r, include=TRUE}
ave.counts <- calcAverage(sce)
hist(log10(ave.counts), breaks=100, main="", col="grey80",
    xlab=expression(Log[10]~"average count"))
```

We also look at the identities of the most highly expressed genes.
This should generally be dominated by constitutively expressed transcripts, such as those for ribosomal or mitochondrial proteins.
The presence of other classes of features may be cause for concern if they are not consistent with expected biology.

```{r}
plotHighestExprs(sce, n=50)
```

```{r, include=TRUE}
clusters <- quickCluster(sce)
sce <- computeSumFactors(sce, cluster=clusters)
```

From: Lun et al. (2016) A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.

"In this case, the size factors are tightly correlated with the library sizes for all cells. This suggests that the
systematic differences between cells are primarily driven by differences in capture efficiency or sequencing depth. Any
DE between cells would yield a non-linear trend between the total count and size factor, and/or increased scatter around
the trend. This does not occur here as strong DE is unlikely to exist within a homogeneous population of cells."

In our case there is also a linear trend, but with some scatter around it.

```{r, include=TRUE}
plot(sizeFactors(sce), sce$total_counts/1e3, log="xy",
ylab="Library size (thousands)", xlab="Size factor")
```

```{r, include=TRUE}
sce <- scater::normalize(sce)
sce
```

# Classification of cell cycle phase  

Do not run because of computational burden!

```{r}
mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", package="scran"))
library(org.Mm.eg.db)
anno <- select(org.Mm.eg.db, keys=rownames(sce), keytype="SYMBOL", column="ENSEMBL")
ensembl <- anno$ENSEMBL[match(rownames(sce), anno$SYMBOL)]
assignments <- cyclone(sce, mm.pairs, gene.names=ensembl)
plot(assignments$score$G1, assignments$score$G2M, xlab="G1 score", ylab="G2/M score", pch=16)
```

From: Lun et al. (2016) A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.

"Given the lack of definitive classification, we will not perform any processing of the dataset by cell cycle phase. This
is unlikely to be problematic for this analysis, as the cell cycle effect will be relatively subtle compared to the obvious
differences between cell types in a diverse population. Thus, the former is unlikely to distort the conclusions regarding
the latter. Indeed, classification may be irrelevant for many neuronal cell types which are postmitotic and do not belong
in any phase of the cell cycle."

Does cell cycle have an effect?

# Modelling the technical component of variation

We identify HVGs to focus on the genes that are driving heterogeneity across the population of cells.
This requires estimation of the variance in expression for each gene, followed by decomposition of the variance into biological and technical components.

From: Lun et al. (2016) A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.

"HVGs  are  defined  as  genes  with  biological  components  that  are  significantly  greater  than  zero  at  a  false  discovery rate (FDR) of 5%. These genes are interesting as they drive differences in the expression profiles between cells, and should be prioritized for further investigation. In addition, we only consider a gene to be a HVG if it has a biological component greater than or equal to 0.5. For transformed expression values on the log2 scale, this means that the average  difference  in  true  expression  between  any  two  cells  will  be  at  least  2-fold.  (This  reasoning  assumes  that the true log-expression values are Normally distributed with variance of 0.5. The root-mean-square of the difference between two values is treated as the average log2-fold change between cells and is equal to unity.) We rank the results by the biological component to focus on genes with larger biological variability."

```{r, include=TRUE}
var.fit <- trendVar(sce, method="loess", loess.args=list(span=0.05), use.spikes=FALSE)
var.out <- decomposeVar(sce, var.fit)
head(var.out)    
```

"We can have a look at the fitted trend.
Some tinkering may be required to get a good fit, usually by modifying `span=`."

```{r hvgplothsc, include=TRUE}
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression")
curve(var.fit$trend(x), add=TRUE, col="dodgerblue", lwd=2)
cur.spike <- isSpike(sce)
points(var.out$mean[cur.spike], var.out$total[cur.spike], col="red", pch=16)
```

```{r, include=TRUE}
#hvg.out <- var.out[which(var.out$FDR <= 0.05 & var.out$bio >= 0.25),]
#hvg.out <- var.out[which(var.out$FDR <= 0.05 & var.out$bio >= 0.01),]
hvg.out <- var.out[with(var.out, order(bio,FDR, decreasing = TRUE)),][1:800,]
hvg.out <- hvg.out[order(hvg.out$bio, decreasing = TRUE),]
nrow(hvg.out)
```

We recommend checking the distribution of expression values for the top HVGs to ensure that the variance estimate is not being dominated by one or two outlier cells.

```{r, include=TRUE}
plotExpression(sce, rownames(hvg.out)[1:10])
```

## Extract highly variable genes (HVG)  
 
```{r, include=TRUE}
sce_hvg <- sce[row.names(hvg.out),]
```

# Seurat clustering analysis  

Convert SingleCellExperiment object into Seurat object.

```{r}
rownames(sce_hvg) <- str_remove(rownames(sce_hvg), "[|]")
```


```{r}
sce_hvg.seurat <- as.Seurat(x = sce_hvg)
```

Scaling data before running PCA.

```{r}
all.genes <- rownames(sce_hvg.seurat)
sce_hvg.seurat <- ScaleData(sce_hvg.seurat, features = all.genes)
```

Remove mitochondrial genes.

```{r removeercc}
sce_hvg.seurat <- sce_hvg.seurat[grep("^(mt)",row.names(sce_hvg.seurat),invert=TRUE),]
```


Run PCA on Seurat object.

```{r}
sce_hvg.seurat <- RunPCA(sce_hvg.seurat, npcs = 60, features = rownames(sce_hvg.seurat))
```

```{r}
VizDimLoadings(sce_hvg.seurat, dims = 1:2, reduction = "pca")
```

```{r}
DimPlot(sce_hvg.seurat, reduction = "pca")
```

```{r}
DimHeatmap(sce_hvg.seurat, dims = 1:10, cells = 500, balanced = TRUE)
```

Heatmap allows to see some structure in the data. It suggest that the first 8 PCs include some structure. These can then be used for the cluster analysis.

# Determine the dimensionality of the dataset  

This part is based on: https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html

"To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many componenets should we choose to include? 10? 20? 100?

In Macosko et al, we implemented a resampling test inspired by the JackStraw procedure. We randomly permute a subset of the data (1% by default) and rerun PCA, constructing a ‘null distribution’ of feature scores, and repeat this procedure. We identify ‘significant’ PCs as those who have a strong enrichment of low p-value features."

```{r}
sce_hvg.seurat <- JackStraw(sce_hvg.seurat, num.replicate = 100, dims = 20)
sce_hvg.seurat <- ScoreJackStraw(sce_hvg.seurat, dims = 1:20)
```

```{r}
JackStrawPlot(sce_hvg.seurat, dims = 1:20, xmax = 0.75, ymax = 1.0)
```

The drop of the p-value at PC8 suggest to use the first 8 dimensions for clustering.

```{r}
ElbowPlot(sce_hvg.seurat, ndims = 15, reduction = "pca")
```

The more approximate elbow plot also suggests to use 8 PCs.

# Cluster evaluation  

Run Seurat clustering with varying resolution parameters to assess cluster stability. Parameter is varied between 0.4 to 1.2 in steps of 0.1. The resulting clusterings are then compared to each other using the adjusted rand index (ARI).

```{r, message=FALSE}
resolution <- seq(0.4, 1.2, 0.1)
sce_hvg.seurat <- FindNeighbors(sce_hvg.seurat, dims = 1:8)
cluster_out <- mclapply(1:length(resolution), function(x){
  sce_hvg.seurat <- FindClusters(sce_hvg.seurat, resolution = resolution[x], algorithm = 1)
  Idents(sce_hvg.seurat)
})

combinations <- combn(1:length(resolution),2)
cluster_ari <- vector(length = ncol(combinations))
for(i in 1:ncol(combinations)){
    cluster_ari[i] <- adjustedRandIndex(cluster_out[[combinations[1,i]]], cluster_out[[combinations[2,i]]]) %>%
      as.data.frame()

    names(cluster_ari[[i]]) <- str_c(as.character(combinations[,i])[1],as.character(combinations[,i])[2], sep="_")
}
cluster_ari <- unlist(cluster_ari)
cluster_ari
```

Compute average silhouette width for resolution parameter.

```{r}
avg_sil_width <- lapply(1:length(cluster_out), function(x){
    sil_out <- cluster::silhouette(as.integer(cluster_out[[x]]),dist(t(log1p(GetAssayData(sce_hvg.seurat)))))
    summary(sil_out[,3])
})
avg_sil_width
```


# Cluster the cells  

Using a resolution of 0.4 seems to be the most stable version according to the average silhouette and ARI.

```{r}
sce_hvg.seurat <- FindNeighbors(sce_hvg.seurat, dims = 1:8)
sce_hvg.seurat <- FindClusters(sce_hvg.seurat, resolution = 0.4, algorithm = 1)
```

```{r}
head(Idents(sce_hvg.seurat), 5)
```

# Run t-SNE for visualization in two dimensions  

```{r}
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages = 'umap-learn')
#sce_hvg.seurat <- RunUMAP(pbmc, dims = 1:10)
```


```{r}
sce_hvg.seurat <- RunTSNE(sce_hvg.seurat, dims = 1:10)
DimPlot(sce_hvg.seurat, reduction = "tsne")
```

# Finding differentially expressed features (cluster biomarkers)  

## Cluster 0  

```{r}
# find all markers of cluster 0
cluster0.markers <- FindMarkers(sce_hvg.seurat, ident.1 = 0)
head(cluster0.markers, n = 5)
```

```{r}
FeaturePlot(sce_hvg.seurat, features = c(row.names(cluster0.markers)[1:4]))
```

## Cluster 1  

```{r}
# find all markers of cluster 1
cluster1.markers <- FindMarkers(sce_hvg.seurat, ident.1 = 1)
head(cluster1.markers, n = 5)
```

```{r}
FeaturePlot(sce_hvg.seurat, features = c(row.names(cluster1.markers)[1:4]))
```

## Cluster 2  

```{r}
# find all markers of cluster 2
cluster2.markers <- FindMarkers(sce_hvg.seurat, ident.1 = 2)
head(cluster2.markers, n = 5)
```

```{r}
FeaturePlot(sce_hvg.seurat, features = c(row.names(cluster2.markers)[1:4]))
```

```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
sce_hvg.seurat.markers <- FindAllMarkers(sce_hvg.seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
sce_hvg.seurat.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
```


```{r}
top10 <- sce_hvg.seurat.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DoHeatmap(sce_hvg.seurat, features = top10$gene) + NoLegend()
```


```{r}
DimPlot(sce_hvg.seurat, reduction = "tsne", split.by = "condition", pt.size = 3)
```

Cluster number 2 seems to be missing under EPC condition, but we don´t know whether the difference is due to the plates the samples were processed on or whether it´s a biological effect.

```{r pcaplothsc, include=TRUE, fig.height=10, fig.width=10}
plotPCA(sce_hvg, ncomponents=4, colour_by="condition")
```

# Identify differential expressed genes across conditions  

From: https://satijalab.org/seurat/v3.0/immune_alignment.html

```{r}
#clust2 <- subset(sce_hvg.seurat, idents = "2")
#Idents(clust2) <- "knockout"
#avg.clust2 <- log1p(AverageExpression(clust2, verbose = FALSE)$RNA)
#avg.clust2$gene <- rownames(avg.clust2)

#clust0 <- subset(sce_hvg.seurat, idents = "0")
#Idents(clust0) <- "knockout"
#avg.clust0 <- log1p(AverageExpression(clust0, verbose = FALSE)$RNA)
#avg.clust0$gene <- rownames(avg.clust0)

#genes.to.label = c("Lhx6", "Maf", "Slc1a3", "Aldoc")
#p1 <- ggplot(avg.clust2, aes(controll, knockout)) + geom_point() + ggtitle("Cluster 2")
#p1 <- LabelPoints(plot = p1, points = genes.to.label, repel = TRUE)
#p2 <- ggplot(avg.clust0, aes(controll, knockout)) + geom_point() + ggtitle("Cluster 0")
#p2 <- LabelPoints(plot = p2, points = genes.to.label, repel = TRUE)
#fig1 <- cowplot::plot_grid(p1, p2)
#fig1
```

```{r}
plots <- VlnPlot(sce_hvg.seurat, features = c("Sox4","Map2"), split.by = "condition", group.by = "seurat_clusters", 
    pt.size = 0, combine = FALSE)
fig2 <- CombinePlots(plots = plots, ncol = 1)
fig2
```

# Using Slingshot for pseudotime analysis  

From: https://www.bioconductor.org/packages/release/bioc/vignettes/slingshot/inst/doc/vignette.html#using-slingshot

```{r}
sce_hvg.slingshot <- as.SingleCellExperiment(sce_hvg.seurat)
```

## Gaussian mixture model for clustering  

```{r}
#cl1 <- Mclust(reducedDim(sce_hvg.slingshot)[,1:2])$classification
cl1 <- Idents(sce_hvg.seurat)
colData(sce_hvg.slingshot)$GMM <- cl1

plot(reducedDim(sce_hvg.slingshot)[,1:2], col = brewer.pal(9,"Set1")[cl1], pch=16, asp = 1)
```



```{r}
sce_hvg.slingshot <- slingshot::slingshot(sce_hvg.slingshot, clusterLabels = 'GMM', reducedDim = 'PCA')
```

```{r}
#saveRDS(file="sce_hvg.slingshot", sce_hvg.slingshot)
```

```{r}
sce_hvg.slingshot <- readRDS(file="sce_hvg.slingshot")
```

```{r}
summary(sce_hvg.slingshot$slingPseudotime_1)
```

```{r}
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce_hvg.slingshot$slingPseudotime_1, breaks=100)]

plot(reducedDims(sce_hvg.slingshot)$PCA, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce_hvg.slingshot), lwd=2, col='black')
```

```{r}
plot(reducedDims(sce_hvg.slingshot)$PCA, col = brewer.pal(9,'Set1')[sce_hvg.slingshot$seurat_clusters], pch=16, asp = 1)
lines(SlingshotDataSet(sce_hvg.slingshot), lwd=2, type = 'lineages', col = 'black')
```

```{r}
l1 <- getLineages(reducedDim(sce_hvg.slingshot), sce_hvg.slingshot$GMM)
#plot_tree(pcaX, clus, l1, threeD = TRUE)
#plot_tree(reducedDim(sce_hvg.slingshot), sce_hvg.slingshot$seurat_clusters, l1, dim = 3)
plot(reducedDim(sce_hvg.slingshot), col = brewer.pal(9,"Set1")[sce_hvg.slingshot$seurat_clusters], asp = 1, pch = 16)
lines(l1, lwd = 3, col = 'black')
```


# Identifying temporally expressed genes  

```{r}
t <- sce_hvg.slingshot$slingPseudotime_1

# for time, only look at the 100 most variable genes
Y <- assays(sce_hvg.slingshot)$logcount
var1K <- names(sort(apply(Y,1,var),decreasing = TRUE))[1:500]
Y <- Y[var1K,]

# fit a GAM with a loess term for pseudotime
gam.pval <- apply(Y,1,function(z){
    d <- data.frame(z=z, t=t)
    tmp <- gam(z ~ lo(t), data=d)
    p <- summary(tmp)[4][[1]][1,5]
    p
})
```

```{r}
topgenes <- names(sort(gam.pval, decreasing = FALSE))[1:100]
heatdata <- assays(sce_hvg.slingshot)$logcount[rownames(assays(sce_hvg.slingshot)$logcount) %in% topgenes, 
    order(t, na.last = NA)]
heatclus <- sce_hvg.slingshot$seurat_clusters[order(t, na.last = NA)]
ce <- clusterExperiment::ClusterExperiment(heatdata, heatclus, transformation = log1p)
clusterExperiment::plotHeatmap(ce, clusterSamplesData = "orderSamplesValue",
    visualizeData = 'transformed')
```

# Session info  

```{r, echo=TRUE}
sessionInfo()
```







